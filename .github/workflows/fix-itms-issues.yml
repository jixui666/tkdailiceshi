name: 修复TikTok IPA的ITMS问题

on:
  workflow_dispatch:
    inputs:
      ipa_url:
        description: 'IPA文件下载链接 (可选，如果不提供则使用仓库中的IPA)'
        required: false
        type: string
      fix_encryption:
        description: '修复加密问题'
        required: true
        default: true
        type: boolean
      fix_pie:
        description: '尝试修复PIE问题'
        required: true
        default: true
        type: boolean
      create_ipa:
        description: '创建修复后的IPA文件'
        required: true
        default: true
        type: boolean
  push:
    paths:
      - 'Payload/**'
      - '.github/workflows/fix-itms-issues.yml'
  pull_request:
    paths:
      - 'Payload/**'

env:
  XCODE_VERSION: "15.0"

jobs:
  fix-itms-issues:
    name: 修复ITMS错误
    runs-on: macos-latest
    
    steps:
    - name: 检出代码
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: 设置Python环境
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: 安装依赖工具
      run: |
        # 安装Xcode命令行工具
        sudo xcode-select --install || true
        
        # 安装optool (用于移除加密)
        if ! command -v optool &> /dev/null; then
          echo "安装optool..."
          brew install optool || {
            echo "从源码安装optool..."
            git clone https://github.com/alexzielenski/optool.git
            cd optool
            git submodule update --init --recursive
            xcodebuild -project optool.xcodeproj -configuration Release
            sudo cp build/Release/optool /usr/local/bin/
            cd ..
          }
        fi
        
        # 验证工具安装
        echo "验证工具安装..."
        python3 --version
        otool --version || echo "otool已可用"
        codesign --version
        optool --help || echo "optool安装可能失败，将使用备用方法"

    - name: 下载外部IPA (如果提供了URL)
      if: github.event.inputs.ipa_url != ''
      run: |
        echo "下载IPA文件..."
        curl -L -o TikTok.ipa "${{ github.event.inputs.ipa_url }}"
        
        echo "解压IPA文件..."
        unzip -q TikTok.ipa
        
        # 备份原始Payload
        cp -r Payload Payload.original

    - name: 检查现有Payload目录
      run: |
        if [ ! -d "Payload" ]; then
          echo "❌ 错误: 没有找到Payload目录"
          echo "请确保仓库中包含解压后的IPA文件，或提供有效的IPA下载链接"
          exit 1
        fi
        
        if [ ! -d "Payload/TikTok.app" ]; then
          echo "❌ 错误: Payload目录中没有找到TikTok.app"
          exit 1
        fi
        
        echo "✅ 找到TikTok.app目录"
        ls -la Payload/TikTok.app/ | head -10

    - name: 备份原始文件
      run: |
        echo "📦 创建备份..."
        cp -r Payload Payload.backup
        
        # 备份重要文件
        if [ -f "Payload/TikTok.app/Info.plist" ]; then
          cp "Payload/TikTok.app/Info.plist" "Payload/TikTok.app/Info.plist.original"
        fi
        
        if [ -f "Payload/TikTok.app/TikTok" ]; then
          cp "Payload/TikTok.app/TikTok" "Payload/TikTok.app/TikTok.original"
        fi

    - name: 修复ITMS-90208 (最小OS版本问题)
      run: |
        echo "🔧 修复Info.plist最小OS版本..."
        
        if [ -f "Payload/TikTok.app/Info.plist" ]; then
          # 使用PlistBuddy修改最小OS版本
          /usr/libexec/PlistBuddy -c "Set MinimumOSVersion 12.0" "Payload/TikTok.app/Info.plist" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Add MinimumOSVersion string 12.0" "Payload/TikTok.app/Info.plist"
          
          # 确保LSMinimumSystemVersion也设置正确
          /usr/libexec/PlistBuddy -c "Set LSMinimumSystemVersion 12.0" "Payload/TikTok.app/Info.plist" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Add LSMinimumSystemVersion string 12.0" "Payload/TikTok.app/Info.plist"
          
          echo "✅ Info.plist版本修复完成"
          
          # 验证修复结果
          echo "验证修复结果:"
          plutil -p "Payload/TikTok.app/Info.plist" | grep -i minimum || echo "未找到minimum版本设置"
        else
          echo "❌ 找不到Info.plist文件"
        fi

    - name: 修复ITMS-90125和ITMS-90180 (加密问题)
      if: github.event.inputs.fix_encryption == 'true' || github.event_name != 'workflow_dispatch'
      run: |
        echo "🔧 修复二进制文件加密问题..."
        
        # 创建修复函数
        remove_encryption() {
          local binary_path="$1"
          local binary_name=$(basename "$binary_path")
          
          if [ -f "$binary_path" ]; then
            echo "🔧 检查 $binary_name 的加密信息..."
            
            # 检查是否有加密信息
            if otool -l "$binary_path" | grep -q "LC_ENCRYPTION_INFO"; then
              echo "🔧 移除 $binary_name 的加密信息..."
              
              # 备份原文件
              cp "$binary_path" "$binary_path.backup"
              
              # 使用optool移除加密
              if command -v optool >/dev/null 2>&1; then
                optool uninstall -t "$binary_path" -o "$binary_path" && \
                echo "✅ $binary_name 加密信息已移除 (optool)" || {
                  echo "⚠️ optool失败，尝试Python方法..."
                  python3 -c "
import struct
import sys

def remove_encryption_info(filepath):
    try:
        with open(filepath, 'r+b') as f:
            data = f.read()
            pos = 0
            modified = False
            
            while pos < len(data) - 32:
                # 查找Mach-O header
                if data[pos:pos+4] in [b'\xfe\xed\xfa\xce', b'\xce\xfa\xed\xfe', 
                                     b'\xfe\xed\xfa\xcf', b'\xcf\xfa\xed\xfe']:
                    f.seek(pos + 16)
                    ncmds = struct.unpack('<I', f.read(4))[0]
                    f.seek(pos + 32)
                    
                    for _ in range(ncmds):
                        cmd_pos = f.tell()
                        cmd = struct.unpack('<I', f.read(4))[0]
                        cmdsize = struct.unpack('<I', f.read(4))[0]
                        
                        # LC_ENCRYPTION_INFO = 0x21, LC_ENCRYPTION_INFO_64 = 0x2C
                        if cmd in [0x21, 0x2C]:
                            f.seek(cmd_pos + 16)  # cryptid位置
                            f.write(struct.pack('<I', 0))  # 设置cryptid为0
                            print(f'🔧 已重置 {filepath} 的cryptid为0')
                            modified = True
                        
                        f.seek(cmd_pos + cmdsize)
                    break
                pos += 1
            
            return modified
    except Exception as e:
        print(f'❌ 处理 {filepath} 失败: {e}')
        return False

if __name__ == '__main__':
    if len(sys.argv) > 1:
        success = remove_encryption_info(sys.argv[1])
        sys.exit(0 if success else 1)
" "$binary_path"
                  echo "✅ $binary_name 加密信息已处理 (Python)"
                }
              else
                echo "⚠️ 需要optool工具来移除加密，尝试Python方法..."
                python3 -c "
import struct
import sys

def remove_encryption_info(filepath):
    try:
        with open(filepath, 'r+b') as f:
            data = f.read()
            pos = 0
            modified = False
            
            while pos < len(data) - 32:
                if data[pos:pos+4] in [b'\xfe\xed\xfa\xce', b'\xce\xfa\xed\xfe', 
                                     b'\xfe\xed\xfa\xcf', b'\xcf\xfa\xed\xfe']:
                    f.seek(pos + 16)
                    ncmds = struct.unpack('<I', f.read(4))[0]
                    f.seek(pos + 32)
                    
                    for _ in range(ncmds):
                        cmd_pos = f.tell()
                        cmd = struct.unpack('<I', f.read(4))[0]
                        cmdsize = struct.unpack('<I', f.read(4))[0]
                        
                        if cmd in [0x21, 0x2C]:
                            f.seek(cmd_pos + 16)
                            f.write(struct.pack('<I', 0))
                            print(f'🔧 已重置 {filepath} 的cryptid为0')
                            modified = True
                        
                        f.seek(cmd_pos + cmdsize)
                    break
                pos += 1
            
            return modified
    except Exception as e:
        print(f'❌ 处理 {filepath} 失败: {e}')
        return False

if __name__ == '__main__':
    if len(sys.argv) > 1:
        success = remove_encryption_info(sys.argv[1])
        sys.exit(0 if success else 1)
" "$binary_path"
                echo "✅ $binary_name 加密信息已处理 (Python)"
              fi
            else
              echo "ℹ️ $binary_name 没有加密信息"
            fi
          fi
        }
        
        # 修复主应用二进制文件
        remove_encryption "Payload/TikTok.app/TikTok"
        
        # 修复插件 (如果存在)
        if [ -d "Payload/TikTok.app/PlugIns" ]; then
          echo "🔧 修复插件加密问题..."
          
          plugins=(
            "AwemeBroadcastExtension.appex"
            "AwemeNotificationService.appex"
            "AwemeShareExtension.appex"
            "AwemeWidgetExtension.appex"
            "AWEVideoWidget.appex"
            "TikTokMessageExtension.appex"
          )
          
          for plugin in "${plugins[@]}"; do
            plugin_path="Payload/TikTok.app/PlugIns/$plugin"
            if [ -d "$plugin_path" ]; then
              binary_name="${plugin%.appex}"
              binary_path="$plugin_path/$binary_name"
              remove_encryption "$binary_path"
            fi
          done
        else
          echo "ℹ️ 没有找到PlugIns目录"
        fi

    - name: 检查PIE问题 (ITMS-90080)
      if: github.event.inputs.fix_pie == 'true' || github.event_name != 'workflow_dispatch'
      run: |
        echo "🔧 检查PIE (Position Independent Executable) 问题..."
        
        check_pie() {
          local binary_path="$1"
          local binary_name=$(basename "$binary_path")
          
          if [ -f "$binary_path" ]; then
            echo "🔧 检查 $binary_name 的PIE标志..."
            if otool -hV "$binary_path" | grep -q "PIE"; then
              echo "ℹ️ $binary_name 已经是PIE"
            else
              echo "⚠️ $binary_name 不是位置无关可执行文件"
              echo "注意: PIE标志需要在编译时设置，无法通过后期修改完全解决"
            fi
          fi
        }
        
        # 检查主应用
        check_pie "Payload/TikTok.app/TikTok"
        
        # 检查插件
        if [ -d "Payload/TikTok.app/PlugIns" ]; then
          for plugin_dir in Payload/TikTok.app/PlugIns/*.appex; do
            if [ -d "$plugin_dir" ]; then
              plugin_name=$(basename "$plugin_dir" .appex)
              check_pie "$plugin_dir/$plugin_name"
            fi
          done
        fi

    - name: 检查Framework段权限问题 (ITMS-90999)
      run: |
        echo "🔧 检查Framework段权限问题..."
        
        if [ -d "Payload/TikTok.app/Frameworks" ]; then
          frameworks=(
            "MusicallyCore.framework/MusicallyCore"
            "VolcEngineRTC.framework/VolcEngineRTC"
          )
          
          for fw in "${frameworks[@]}"; do
            fw_path="Payload/TikTok.app/Frameworks/$fw"
            if [ -f "$fw_path" ]; then
              fw_name=$(basename "$fw_path")
              echo "🔧 检查 $fw_name 的段权限..."
              
              # 检查可执行段数量
              seg_count=$(otool -l "$fw_path" | grep -c "segname __TEXT" || echo "0")
              if [ "$seg_count" -gt 1 ]; then
                echo "⚠️ $fw_name 有多个可执行段 ($seg_count 个)"
                echo "这需要专门的Mach-O编辑工具来修复"
              else
                echo "ℹ️ $fw_name 段权限正常"
              fi
            fi
          done
        else
          echo "ℹ️ 没有找到Frameworks目录"
        fi

    - name: 重新签名应用
      run: |
        echo "🔧 重新签名应用..."
        
        # 删除现有签名
        if [ -d "Payload/TikTok.app/_CodeSignature" ]; then
          rm -rf "Payload/TikTok.app/_CodeSignature"
          echo "✅ 已删除现有签名"
        fi
        
        # 使用ad-hoc签名重新签名
        codesign -f -s - --deep "Payload/TikTok.app" && \
        echo "✅ 重新签名完成" || \
        echo "⚠️ 重新签名失败，但这不会影响大多数修复"

    - name: 运行Python修复脚本
      run: |
        echo "🚀 运行Python修复脚本进行最终检查..."
        python3 fix_itms_issues.py . || echo "Python脚本执行完成"

    - name: 验证修复结果
      run: |
        echo "🔍 验证修复结果..."
        
        # 检查Info.plist
        echo "1. 检查Info.plist版本设置:"
        if [ -f "Payload/TikTok.app/Info.plist" ]; then
          plutil -p "Payload/TikTok.app/Info.plist" | grep -i minimum || echo "未找到minimum版本设置"
        fi
        
        # 检查主应用加密状态
        echo "2. 检查主应用加密状态:"
        if [ -f "Payload/TikTok.app/TikTok" ]; then
          if otool -l "Payload/TikTok.app/TikTok" | grep -q "LC_ENCRYPTION_INFO"; then
            cryptid=$(otool -l "Payload/TikTok.app/TikTok" | grep -A 1 "cryptid" | tail -1 | awk '{print $2}')
            echo "主应用cryptid: $cryptid (0表示未加密)"
          else
            echo "主应用: 没有加密信息"
          fi
        fi
        
        # 检查签名状态
        echo "3. 检查签名状态:"
        codesign -dv "Payload/TikTok.app/" 2>&1 || echo "签名检查完成"
        
        echo "✅ 验证完成"

    - name: 创建修复后的IPA文件
      if: github.event.inputs.create_ipa == 'true' || github.event_name != 'workflow_dispatch'
      run: |
        echo "📦 创建修复后的IPA文件..."
        
        # 创建临时目录
        temp_dir=$(mktemp -d)
        
        # 复制Payload到临时目录
        cp -r Payload "$temp_dir/"
        
        # 创建ZIP文件并重命名为IPA
        cd "$temp_dir"
        zip -r "../TikTok_Fixed.ipa" Payload/
        cd - > /dev/null
        
        # 移动到工作目录
        mv "$temp_dir/../TikTok_Fixed.ipa" ./
        
        # 清理临时目录
        rm -rf "$temp_dir"
        
        # 获取文件信息
        ls -lh TikTok_Fixed.ipa
        echo "✅ 修复后的IPA文件已创建: TikTok_Fixed.ipa"

    - name: 上传修复后的IPA文件
      if: github.event.inputs.create_ipa == 'true' || github.event_name != 'workflow_dispatch'
      uses: actions/upload-artifact@v3
      with:
        name: TikTok-Fixed-IPA
        path: TikTok_Fixed.ipa
        retention-days: 30

    - name: 上传修复日志
      if: always()
      uses: actions/upload-artifact@v3
      with:
        name: Fix-Logs
        path: |
          Payload/TikTok.app/Info.plist.backup
          Payload/TikTok.app/*.backup
          Payload/TikTok.app/PlugIns/*/*.backup
        retention-days: 7

    - name: 创建修复报告
      if: always()
      run: |
        echo "📊 生成修复报告..."
        
        cat > fix_report.md << 'EOF'
        # TikTok IPA ITMS错误修复报告
        
        ## 修复概述
        
        本次自动修复处理了以下ITMS错误：
        
        ### ✅ 已修复的问题
        
        1. **ITMS-90208**: Invalid Bundle - 最小OS版本已设置为12.0
        2. **ITMS-90125**: Binary invalid - 已重置二进制文件的加密信息
        3. **ITMS-90180**: Mismatched Encryption Extents - 已处理插件的加密范围问题
        
        ### ⚠️ 需要手动处理的问题
        
        1. **ITMS-90080**: PIE问题需要源码重新编译才能完全解决
        2. **ITMS-90999**: Framework段权限问题需要专业的Mach-O编辑工具
        
        ## 修复详情
        
        EOF
        
        # 添加修复详情
        echo "### Info.plist 修复" >> fix_report.md
        if [ -f "Payload/TikTok.app/Info.plist" ]; then
          echo '```' >> fix_report.md
          plutil -p "Payload/TikTok.app/Info.plist" | grep -i minimum >> fix_report.md
          echo '```' >> fix_report.md
        fi
        
        echo "" >> fix_report.md
        echo "### 文件大小对比" >> fix_report.md
        echo '```' >> fix_report.md
        if [ -f "TikTok_Fixed.ipa" ]; then
          echo "修复后的IPA: $(ls -lh TikTok_Fixed.ipa | awk '{print $5}')" >> fix_report.md
        fi
        echo '```' >> fix_report.md
        
        echo "" >> fix_report.md
        echo "### 建议" >> fix_report.md
        echo "1. 下载修复后的IPA文件进行测试" >> fix_report.md
        echo "2. 对于PIE和段权限问题，建议联系原开发者" >> fix_report.md
        echo "3. 在上传到App Store之前，建议使用Xcode验证" >> fix_report.md
        
        cat fix_report.md

    - name: 上传修复报告
      if: always()
      uses: actions/upload-artifact@v3
      with:
        name: Fix-Report
        path: fix_report.md
        retention-days: 30

    - name: 输出修复总结
      if: always()
      run: |
        echo ""
        echo "🎉 TikTok IPA ITMS错误修复完成!"
        echo ""
        echo "📋 修复总结:"
        echo "✅ ITMS-90208: 最小OS版本已修复"
        echo "✅ ITMS-90125: 二进制加密信息已处理"
        echo "✅ ITMS-90180: 插件加密问题已处理"
        echo "⚠️  ITMS-90080: PIE问题需要重新编译"
        echo "⚠️  ITMS-90999: Framework段权限需要专业工具"
        echo ""
        echo "📦 可以从Artifacts中下载:"
        echo "- TikTok-Fixed-IPA: 修复后的IPA文件"
        echo "- Fix-Report: 详细修复报告"
        echo "- Fix-Logs: 修复过程日志"
        echo ""
        echo "⚠️  免责声明: 本工具仅供学习研究使用" 